# WebXR Vanilla Plane Detection - Development Rules

## ðŸŽ¯ **Project Status: Production-Ready Advanced WebXR System**

This is a **state-of-the-art WebXR application** with advanced cursor system, hit-testing, plane visualization, and cube repositioning. The codebase is production-ready and follows WebXR specifications.

## ðŸ—ï¸ **Current Architecture (DO NOT DUPLICATE)**

The project has evolved into a sophisticated system with:
- **HitTestManager**: WebXR hit-test API implementation
- **CursorManager**: Real-time visual feedback system
- **PlaneVisualizer**: Dynamic surface highlighting
- **Advanced State Management**: Multi-state placement with repositioning
- **Complete Resource Management**: Memory leak prevention

## ðŸ› ï¸ **Development Guidelines**

### **Code Style & Standards**
```javascript
// âœ… Follow established patterns
class InteractionManager {
  constructor(scene, sceneGroups = null) {
    this.scene = scene
    this.isDisposed = false
    
    // Use existing scene groups structure
    if (sceneGroups?.cursors) {
      this.targetGroup = sceneGroups.cursors
    }
  }
  
  dispose() {
    if (this.isDisposed) return
    this.isDisposed = true
    // Complete cleanup
  }
}
```

### **WebXR Implementation Rules**

#### **1. Always Follow WebXR Specifications**
```javascript
// âœ… Correct: Use entity types per W3C spec
const hitTestSource = await session.requestHitTestSource({
  space: inputSource.targetRaySpace,
  entityTypes: ['plane', 'point'] // Required by specification
});

// âŒ Incorrect: Missing entity types
const hitTestSource = await session.requestHitTestSource({
  space: inputSource.targetRaySpace
});
```

#### **2. State Management Patterns**
```javascript
// âœ… Use established placement states
this.placementState = 'scanning' | 'targeting' | 'preview' | 'placed' | 'repositioning'

// âœ… Always check disposal state
if (this.isDisposed) return

// âœ… Prevent race conditions
if (!this.hitTestSetupInProgress) {
  this.hitTestSetupInProgress = true
  // async operation
}
```

#### **3. Memory Management Requirements**
```javascript
// âœ… Always implement disposal pattern
dispose() {
  if (this.isDisposed) return
  this.isDisposed = true
  
  // Dispose Three.js resources
  if (this.material) {
    this.disposeMaterialTextures(this.material)
    this.material.dispose()
  }
  
  if (this.geometry) {
    this.geometry.dispose()
  }
  
  // Clear collections
  this.maps.clear()
}
```

### **Performance Optimization Rules**

#### **1. Efficient Update Patterns**
```javascript
// âœ… Only update when necessary
if (this.activeInputSources.size > 0) {
  this.updateCursors(hitTestResults, time)
} else {
  this.hideAllCursors()
}

// âœ… Debounce expensive operations
if (time - this.lastUpdateTime > UPDATE_THRESHOLD) {
  this.performExpensiveUpdate()
  this.lastUpdateTime = time
}
```

#### **2. Scene Organization**
```javascript
// âœ… Use established scene groups
this.sceneGroups = {
  cursors: new THREE.Group(),      // Visual cursors
  planeVisuals: new THREE.Group(), // Surface highlights  
  content: new THREE.Group()       // Placed objects
}
```

### **Error Handling Standards**

#### **1. WebXR Error Patterns**
```javascript
// âœ… Comprehensive WebXR error handling
try {
  const hitTestResult = frame.getHitTestResults(hitTestSource)
  // Process results
} catch (error) {
  console.warn(`âš ï¸ [DEBUG] Hit-test failed:`, error.message)
  // Fallback to plane detection
  this.fallbackToPlaneDetection(frame)
}
```

#### **2. Validation Patterns**
```javascript
// âœ… Always validate WebXR data
if (!pose || !pose.transform || !pose.transform.position) {
  console.warn('âš ï¸ [DEBUG] Invalid pose data, skipping update')
  return
}
```

### **Logging & Debug Standards**

#### **1. Consistent Logging Format**
```javascript
// âœ… Use emoji prefixes for log categories
console.log('ðŸŽ¯ [DEBUG] Hit-test event:', data)        // Hit-testing
console.log('ðŸŽ¨ [DEBUG] Cursor update:', data)         // Cursor system
console.log('ðŸŽ­ [DEBUG] Plane highlight:', data)       // Plane visualization
console.log('ðŸ“Š [DEBUG] Performance:', data)           // Performance
console.log('âš¡ [DEBUG] Memory event:', data)          // Memory management
console.log('âœ… [DEBUG] Success:', data)               // Success
console.warn('âš ï¸ [DEBUG] Warning:', data)              // Warnings
console.error('âŒ [DEBUG] Error:', data)               // Errors
```

#### **2. Performance Logging Limits**
```javascript
// âœ… Limit console spam (5-second intervals)
if (time - this.lastLogTime > 5000) {
  console.log(`ðŸ“Š [DEBUG] Frame stats: ${fps.toFixed(1)} FPS`)
  this.lastLogTime = time
}
```

## ðŸ”§ **Integration Patterns**

### **Adding New Interaction Systems**
```javascript
// âœ… Follow established manager pattern
export class NewInteractionManager {
  constructor(scene, sceneGroups = null) {
    this.scene = scene
    this.isDisposed = false
    
    // Integrate with scene groups
    if (sceneGroups?.targetGroup) {
      this.parentGroup = sceneGroups.targetGroup
    } else {
      this.parentGroup = new THREE.Group()
      this.scene.add(this.parentGroup)
    }
  }
  
  // Standard interface methods
  update(frame, time) { /* implementation */ }
  dispose() { /* proper cleanup */ }
  getDebugInfo() { /* debug data */ }
}
```

### **Main Application Integration**
```javascript
// âœ… Initialize in startAR method
this.newManager = new NewInteractionManager(this.scene, this.sceneGroups)

// âœ… Update in render loop
if (this.newManager && this.placementState === 'targeting') {
  this.newManager.update(frame, time)
}

// âœ… Dispose in session end
if (this.newManager) {
  this.newManager.dispose()
  this.newManager = null
}
```

## ðŸš« **Anti-Patterns to Avoid**

### **âŒ Memory Leaks**
```javascript
// âŒ Never create objects without disposal
const geometry = new THREE.BoxGeometry() // LEAK!

// âœ… Always plan disposal path
const geometry = new THREE.BoxGeometry()
// Store reference for later disposal
this.geometries.push(geometry)
```

### **âŒ Race Conditions**
```javascript
// âŒ Concurrent async operations
this.setupHitTestSources(sources) // RACE CONDITION!
this.setupHitTestSources(sources) // RACE CONDITION!

// âœ… Prevent concurrent setup
if (!this.setupInProgress) {
  this.setupInProgress = true
  await this.setupHitTestSources(sources)
  this.setupInProgress = false
}
```

### **âŒ Console Spam**
```javascript
// âŒ Logging in render loop without throttling
console.log('Frame update') // 60+ logs per second!

// âœ… Throttled logging
if (time - this.lastLogTime > 5000) {
  console.log('Frame update summary')
  this.lastLogTime = time
}
```

## ðŸ§ª **Testing Requirements**

### **WebXR Compliance Testing**
- âœ… Test on actual Meta Quest 3 hardware
- âœ… Verify hit-test entity types configuration
- âœ… Validate memory cleanup with browser dev tools
- âœ… Test session interruption handling
- âœ… Verify HTTPS deployment

### **Performance Benchmarks**
- âœ… Maintain 60fps during all interactions
- âœ… Memory usage should not increase over time
- âœ… Hit-test latency < 16ms
- âœ… Cursor response time < 5ms

### **User Experience Validation**
- âœ… Cursor appears within 500ms of pointing
- âœ… Plane highlighting responds immediately
- âœ… Repositioning workflow is intuitive
- âœ… Error states provide clear feedback

## ðŸ“ **Code Review Checklist**

### **Before Committing**
- [ ] All managers implement disposal pattern
- [ ] Memory leaks checked with Chrome DevTools
- [ ] WebXR specification compliance verified
- [ ] Error handling covers all WebXR edge cases
- [ ] Console logging follows emoji prefix standards
- [ ] Performance impact measured
- [ ] Quest 3 hardware testing completed

### **Pull Request Requirements**
- [ ] Code follows established patterns
- [ ] No new anti-patterns introduced
- [ ] Memory management validated
- [ ] WebXR specification compliance maintained
- [ ] Comprehensive error handling included
- [ ] Debug logging properly implemented

## ðŸŽ¯ **Current Implementation Status**

**âœ… COMPLETED SYSTEMS:**
- Hit-testing with WebXR API compliance
- Visual cursor system with animations
- Plane visualization and highlighting
- Multi-state placement system
- Cube repositioning via ray-casting
- Complete memory management
- Production-ready error handling

**ðŸš€ FUTURE ENHANCEMENTS:**
- Multiple object placement
- Gesture-based interactions
- Spatial audio integration
- Hand gesture recognition
- Advanced anchor management

---

**Follow these rules religiously to maintain code quality and WebXR specification compliance** âš¡ 